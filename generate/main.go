package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"regexp"
	"slices"
	"strings"
)

// generates a copy of all the feed structs to work around a bug in
// go's encoding/xml lib, see README.md for more detail.
func main() {
	structs, err := parseFileStructs("gopodcast.go")
	if err != nil {
		log.Fatal(err)
	}
	if err := generateFile("gopodcast_xml_fix.go", structs); err != nil {
		log.Fatal(err)
	}
}

var nsToURL = map[string]string{
	"atom":    "http://www.w3.org/2005/Atom",
	"itunes":  "http://www.itunes.com/dtds/podcast-1.0.dtd",
	"podcast": "https://podcastindex.org/namespace/1.0",
	"content": "http://purl.org/rss/1.0/modules/content/",
}

// types we don't want to transform
var ignoreTypes = []string{"string", "bool", "int", "int64", "byte", "xml.Name", "Bool", "Time", "YesNo"}

type strct struct {
	name   string
	fields []field
}

type field struct {
	name  string
	fType string
	tag   string
}

// parses all the structs from a source file along with their fields
func parseFileStructs(fileName string) ([]strct, error) {
	fsrc, err := os.ReadFile(fileName) // #nosec G304 -- no user input, only in code gen
	if err != nil {
		return nil, err
	}

	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, "", fsrc, parser.AllErrors)
	if err != nil {
		return nil, err
	}

	structs := make([]strct, 0)

	lastIdent := ""
	ast.Inspect(f, func(n ast.Node) bool {
		if id, ok := n.(*ast.Ident); ok {
			lastIdent = id.Name
		}

		if n, ok := n.(*ast.StructType); ok {
			strct := strct{
				name:   lastIdent,
				fields: make([]field, 0),
			}
			for _, f := range n.Fields.List {
				tag := ""
				if f.Tag != nil {
					tag = transformXMLTag(f.Tag.Value)
				}
				typeStr := fsrc[f.Type.Pos()-1 : f.Type.End()-1]
				strct.fields = append(strct.fields, field{
					name:  f.Names[0].Name,
					fType: string(typeStr),
					tag:   tag,
				})
			}
			structs = append(structs, strct)
		}
		return true
	})

	return structs, nil
}

func generateFile(fileName string, structs []strct) error {
	output := &bytes.Buffer{}

	fmt.Fprint(output, "// Code generated by gopodcast generator. DO NOT EDIT.\n\n")
	fmt.Fprint(output, "// This file contains copies of structs to fix an issue with namespace prefix support in go `encoding/xml` package\n\n")
	fmt.Fprint(output, "package gopodcast\n\n")
	fmt.Fprint(output, "import \"encoding/xml\"\n\n")

	for _, strct := range structs {
		fmt.Fprintf(output, "type xmlFix%s struct {\n", strct.name)
		for _, field := range strct.fields {
			fmt.Fprintf(output, "\t%s %s %s\n", field.name, transformFieldType(field.fType), field.tag)
		}
		fmt.Fprint(output, "}\n\n")

		fmt.Fprintf(output, "func (s *xmlFix%s) Translate() *%s {\n", strct.name, strct.name)
		fmt.Fprint(output, "if s == nil {\n\treturn nil\n}\n")
		fmt.Fprintf(output, "\tvar r %s\n", strct.name)
		for _, field := range strct.fields {
			if ignoreType(field.fType) {
				fmt.Fprintf(output, "\tr.%s = s.%s\n", field.name, field.name)
				continue
			}

			if isPtr(field.fType) {
				fmt.Fprintf(output, "\tr.%s = s.%s.Translate()\n", field.name, field.name)
			} else if isSlicePtr(field.fType) {
				fmt.Fprintf(output, "\tv%s := make(%s, 0)\n", field.name, field.fType)
				fmt.Fprintf(output, "\tfor _, v := range s.%s {\n", field.name)
				fmt.Fprintf(output, "\t\tv%s = append(v%s, v.Translate())\n", field.name, field.name)
				fmt.Fprint(output, "\t}\n")
				fmt.Fprintf(output, "\tr.%s = v%s\n", field.name, field.name)
			} else if isSlice(field.fType) {
				fmt.Fprintf(output, "\tv%s := make(%s, 0)\n", field.name, field.fType)
				fmt.Fprintf(output, "\tfor _, v := range s.%s {\n", field.name)
				fmt.Fprint(output, "\t\tx := v.Translate()\n")
				fmt.Fprintf(output, "\t\tv%s = append(v%s, *x)\n", field.name, field.name)
				fmt.Fprintf(output, "\t}\n")
				fmt.Fprintf(output, "\tr.%s = v%s\n", field.name, field.name)
			} else {
				fmt.Fprintf(output, "\tv%s := s.%s.Translate()\n", field.name, field.name)
				fmt.Fprintf(output, "\tr.%s = *v%s\n", field.name, field.name)
			}
		}
		fmt.Fprint(output, "\treturn &r\n")
		fmt.Fprint(output, "}\n\n")
	}

	src, err := format.Source(output.Bytes())
	if err != nil {
		return err
	}

	err = os.WriteFile(fileName, src, 0600)
	if err != nil {
		return err
	}

	return nil
}

func transformXMLTag(s string) string {
	r := regexp.MustCompile(`xml:"(([a-zA-Z]+):([a-zA-Z]+))[,"].*`)
	matches := r.FindStringSubmatch(s)
	if len(matches) != 4 {
		return s
	}

	// use NS URL instead of NS when parsing
	ns := matches[2]
	if nsURL, ok := nsToURL[ns]; ok {
		ns = nsURL
	}

	return strings.ReplaceAll(s, matches[1], fmt.Sprintf("%s %s", ns, matches[3]))
}

func transformFieldType(inType string) string {
	prefix := ""
	fType := inType
	n := strings.LastIndexAny(inType, "*[]")
	if n >= 0 {
		prefix = inType[:n+1]
		fType = inType[n+1:]
	}
	if slices.Contains(ignoreTypes, fType) {
		fType = prefix + fType
	} else {
		fType = prefix + "xmlFix" + fType
	}
	return fType
}

func ignoreType(t string) bool {
	return slices.Contains(ignoreTypes, strings.TrimLeft(t, "*[]"))
}

func isPtr(t string) bool {
	return strings.HasPrefix(t, "*")
}

func isSlice(t string) bool {
	return strings.HasPrefix(t, "[")
}

func isSlicePtr(t string) bool {
	return strings.HasPrefix(t, "[]*")
}
